# DB/SQLの覚書

## DMBSは4つの形態がある
1. スタンドアロン型システム
2. ファイル共有型システム
3. サーバ/クライアント型システム
4. Web型システム

## 3層スキーマ構造
データの独立性を高めるための構造。

独立性が高い: データの物理的な構造を変えてもアプリプログラムに影響が出ない

1. 外部スキーマ: 利用者やアプリから見たDBの見た目
2. 概念スキーマ: 開発者から見たDBの論理的構造 = データ構造
3. 内部スキーマ: DBを記録媒体に物理的に記録する際の構造 = ハードウェアとの関係

## ロックの粒度
粒度大 => ロックをかける範囲がでかい。テーブル全体など。他のトランザクションを妨げるのでスループットは低くなる。<br>
粒度小 => ロックをかける範囲が小さい。特定の行など。他のトランザクションからのアクセスができる可能性は高くなる。

## ストアドプロシージャ
SQLの命令群を事前に作り置きしておいて、いざという時に、これから実行する。いちいち命令文を書かなくて済む。

## バックアップファイルとジャーナルファイル
バックアップファイル: 定期的にDBの内容をコピーして他のファイルに保管する
ジャーナルファイル: 更新履歴を保管するファイル。=ログファイル。

更新前ジャーナル => トランザクション => コミット完了 => 更新後ジャーナル

### 更新前ジャーナル
処理を更新する前、つまり、トランザクション発生前にとるジャーナルファイル。

トランザクションが失敗した時、これを使って復元することをロールバック。

### コミット
トランザクションの全てが終わった状態

### 更新後ジャーナル
トランザクション完了後にとるジャーナルファイル

システム障害などでデータが破損した時、これとバックアップファイルを使って復元することをロールフォワード。

## 分散データベースシステム
複数のデータベースを見かけ上１つに見せるような仕組みのこと。

### ２層コミット
分散データベースシステムにおいて、ユーザーに対応するDBが、分散された全てDBにコミットできたか問う。できたなら、コミット実施。１つでもコミットできなければロールバック。というように2層化されたDBのコミットのことを言う。

## SQLのできること
データの集計、整列、グループ分け

## SQLの仕組み
DDLとDMLからなる。

DDL: データを定義する言語。CREATEなど。
DML: データを操作するげん。SELECT, UPDATE, DELETE, INSERT など「CRUD」

## 関係演算
- 選択: 行を取り出す
- 射影: 列を取り出す
- 結合: 複数のテーブルを組み合わせる

## 主キー/外部キー
テーブル同士を結びつけるためのフィールド
主キー: 各テーブルごとにこの値が分かれば、レコードを特定できる。ID。重複しない値（一意制約）。値が空値ではない(非null制約)。
外部キー: 分割されたテーブルを紐づけるキー。
候補キー（複合キー）: テーブルの中でレコードを一位に特定できるキー。生年月日フィールド+氏名フィールド みたいな。

## インデックステーブル
主キーと混同しがち。フィールドの位置を示す情報がのったフィールドを持つテーブル。検索が早い。が登録スピードとトレードオフ。

## CRUD
C: Create 登録<br>
R: Read 取得<br>
U: Update 更新<br>
D: Delete 削除

### 従属性
「部署」が変われば「内線番号」も従って変わる。「内線番号」は「部署」に従属しているデータと言える。

- 関数従属性: xが決まればyも決まるという関係を持つデータ。主キーが各列の値を一意に決定する。
- 多値従属性: とあるフィールドが複数ののフィールドに従属関係を持つこと。
- 結合従属性: 

これら⇩は悪い従属性
- 部分関数従属性: 主キー（複合キー）の一部だけで決定される列が存在すること。各属性の中で部分的に独立したまとまりがあるようなような感じ。（例: 内線番号は部署だけが決まれば決定する。）
- 推移関数従属性: ある非キー属性が主キーを介して間接的に他の属性に依存している状態。


## 正規化
正規化とは、テーブルを複数に分け、個々のテーブル同士を結びつけて、データベースの構造を整理すること。<br>
1つのデータベース内に同じデータが重複して記憶されないようにするのがポイント。

0. 非正規形: 整理されていない状態
1. 第一正規化: 列の繰り返しをなくす
2. 第二正規化: 部分関数従属性を断ち切る
3. 第三正規化: 推移関数従属性を断ち切る === 大体ここで終わる。
4. ボイス・コッド正規化: 第三正規化の不備を補う
5. 第四正規化: 多値従属性を断ち切る
6. 第五正規化: 結合従属性を断ち切る

### 第一正規化
![第一正規化](./img-seikika/seikika-1.webp "第一正規化")

「列」に繰り返し(`table[colspan="2"]`みたいなまとまり)を作らない。<br>
値が重複しても、一つずつフィールドを作る。<br>
一行ずつ情報を取り出せるような状態にする。

また、いらない列も削除する。例えば、単価・数量・金額という列があるとして、金額は単価と数量で得られるから、金額列は省く。

### 第二正規化
![第二正規化](./img-seikika/seikika-2.webp "第二正規化")

部分関数従属性をなくす。そうするためにはテーブルを分割する。

「海賊団コード」と「海賊団名」は各属性の中で独立したまとまりがあり、「海賊団コード」が決まれば「海賊団名」が得られる、という部分関数従属性がある。これを切り分ける。「海賊団コード」を外部キーとすれば良い。

### 第三正規化
![第三正規化](./img-seikika/seikika-3.webp "第三正規化")
第３正規形の説明をするために、第２正規形のテーブルに海賊団での中の役割を表すカラムを追加。

このように【海賊団コード】→【役割コード】→【役割】と言うように二段階の関数従属がある状態を推移的関数従属と呼ぶ。

第３正規化するためには第２正規形と同様に役割の部分を別テーブルに切り離す。

### ボイス・コッド正規化
![ボイス・コッド正規化](./img-seikika/seikika-v_c.webp "ボイス・コッド正規化")

左側のテーブルでは主キーである団員コード・海賊団コードからキャプテンへの関数従属性がある。<br>
一方で各海賊団にキャプテンは一人なので、キャンテンから海賊団コードに対しても関数従属性がある。<br>

### 第四正規化
![第四正規化](./img-seikika/seikika-4.webp "第四正規化")

このテーブルでは団員コードが定まると複数の武器データが定まります。このようなキーと集合との対応を他値従属性と呼びます。<br>
多値従属性が複数存在するテーブルを分割することで第４正規化を行うことができます。

### 第五正規化
![第五正規化](./img-seikika/seikika-5.webp "第五正規化")

先ほどの例で海賊団と武器に関連があると想定します（無理矢理ですが、麦わら海賊団でなければ和道一文字が使えないというルール）。<br>
そうすると最初のテーブルでは海賊団コードと武器の従属性がわからないため、海賊団コードと武器の関連エンティティを作る必要があります。<br>
このように関連がある場合はそれに対応する関連エンティティを作る、ということが第５正規形のルールです。


## MySQL文法
### SELECT フィールド名, フィールド名1, フィールド名2
フィールド名, フィールド名1, フィールド名2 をを取得せよ。選択

### FROM テーブル名, テーブル名1
テーブル名, テーブル名1 から

### WHERE 条件1 & 条件2
条件1 かつ 条件2 にて。射影

## SQLite 
### dbファイルを作成する
`sqlite3 ファイル名.db`<br>
sqlite>プロンプトに切り替わる。

### sqlite>プロンプト:
「.」で始まる命令によってSQLiteの設定に関する操作を行う。ちなみにこの命令はSGL文ではない。SQL文ではなく、SQLiteの「ドットコマンド」（dot command）と呼ばれる。

`.read ファイル名.sql`: sqlファイルを読み込む。<br>
ちなみに、問題なければ、メッセージは特に起きず、次のプロンプトが表示される。

`.tables`: DBに作られたテーブルの一覧が表示される。

`.exit`: プロンプトやターミナルを終了させる。

`.header on`: ヘッダーを表示する。保存されない（.exitでリセットされる）

`.mode column`: 表示モードをカラムにする。（.exitでリセットされる）

### データを取り出す
```
SELECT * FROM テーブル名;
```
*: テーブルから全てのカラムを取り出す。

```
SELECT DISTINCT カラム名 FROM テーブル名;
```
重複を取り除いてカラムを取り出す。distinct=明確な

```
SELECT カラム名 AS 別名 テーブル名;
```
`AS 別名`でカラム名を別名(= エイリアス)で表示させる。<br>
エイリアスに記号を付けたい場合は`""`をつける。`"<商品名>"`

```
SELECT * FROM テーブル名 WHERE 条件式;
```
条件式にマッチしたデータを取り出す。<br>
ちなみに`<>`という比較演算子はrubyとかの`!=`に相当する。

```
SELECT * FROM sales WHERE date >= "2023-04-11";
```
データが`yyyy-mm-dd`の場合、日付データとなり、日付データとして演算できる。

```
WHERE カラム名 IN (データ1, データ2, ...)
```
IN演算子を使うことで、カラム名の値がデータ1かデータ2か...に一致するものを表示。`()`をリストという。

```
WHERE カラム名 BETWEEN 値1 AND 値2
```
BETWEEN_AND演算子を使うことで、特定の範囲を指定する。数や日付に使う。

## 集計関数

| 関数 | 意味 |
|-----|-----|
|COUNT|テーブルのレコード数を求める|
|SUM|指定したカラムの 合計 を求める|
|AVG|指定したカラムの 平均値 を求める|
|MIN|指定したカラムの 最小値 を求める|
|MAX|指定したカラムの 最大値 を求める|

### レコード数を数える
レコード数とは？: 列の大きさ。
```
SELECT COUNT(引数) FROM テーブル名
```
引数は`*`にすることが多い。
ちなみに`COUNT(引数) AS エイリアス名`とすると、エイリアスを設定できる。

### 指定したカラムの合計値を求める
```
SELECT SUM(カラム名) FROM sales;
```

### 指定したカラムの平均値を求める
```
SELECT AVG(カラム名) FROM sales;
```

### 指定したカラムの最大値と最小値を求める
```
SELECT MIN(カラム名), MAX(カラム名) FROM sales;
```

### グループ化した値を結合させる
```
SELECT カラム名1, GROUP_CONCAT(カラム名2) FROM テーブル名
GROUP BY カラム名1;
```
カラム名1でグループ化し、グループごとにカラム名2の値を連結する。<br>
ちなみに、`GROUP_CONCAT(DISTINCT カラム名2)`でカラム名2の値の重複をなくす。


## データをグループ化する
```
SELECT カラム名, 関数(引数) FROM テーブル名
GROUP BY カラム名;
```
GROUP_BY句を使うときは、SELECT句と同じカラム名を使う必要がある。

## グループ化した結果に条件を指定する
集計した結果に対して、条件をつけるときは、`HAVING`句を使う。
```
SELECT カラム名, 集計関数 FROM テーブル名
GROUP BY カラム名 HAVING 条件式;
```
なぜWEHREでじゃないの？: WHERE句はGROUP_BY句より先に実行されるため、集計関数を扱うことはできない。

## データを並べ替える
```
SELECT * FROM テーブル名 ORDER BY 並べ替え基準のカラム;
```
昇順(`ASC`)となる。`並べ替え基準のカラム DESC`とすると降順となる。<br>
また、`並べ替え基準のカラム1 DESC, 並べ替え基準のカラム2 DESC`のように順番を複数指定できる。<br>
さらに、グループ化した後であれば、`関数(並べ替え基準のカラム2)`とすると、関数の実行した値を元に並び替える。

```
SELECT item_name, SUM(item_count) FROM sales
WHERE item_name <> "バナナ"
GROUP BY item_name HAVING SUM(item_count) > 2
ORDER BY SUM(item_count) DESC;
```

## 比較演算子の処理順位
1. <, >, >=, <=
2. =, <>
3. NOT
4. AND
5. OR

```
sqlite> SELECT * FROM sales
   ...> WHERE customer = "サル橋" OR customer = "ウサ田"
   ...> AND item_name = "リンゴ";
```
この場合、ANDがORより強いので`(customer = "ウサ田" AND item_name = "リンゴ") OR customer = "サル橋"`となる。

## 句の実行順
1. FROM
2. INNER JOIN ON
3. WHERE
4. GROUP BY (with 集合関数)
5. HAVING
6. SELECT
7. ORDER BY

## 書き順
1. SLECT,集合関数（SUMなど）
2. FROM
3. INNER JOIN
4. WHERE
5. GROUP BY, HAVING
6. ORDER BY

```
SELECT ...            -- ① カラムや集約関数
FROM ...              -- ② テーブル
[INNER JOIN ...]      -- ③ 結合
WHERE ...             -- ④ 行のフィルタ
GROUP BY ...          -- ⑤ グループ化
HAVING ...            -- ⑥ グループ後のフィルタ
ORDER BY ...          -- ⑦ 並び替え
LIMIT ...
```

## バックアップをとる
```
.backup 作成するファイル名.back
```
## バックアップから復元する
```
.restore バックアップファイル名.back
```

## データを作成(追加)する
```
INSERT INTO テーブル名 (カラム名1, カラム名2, ...)
VALUE (値1, 値2, ...)
```
ちなみにカラム名を省略できる。
```
INSERT INTO テーブル名 VALUE (値1, 値2, ...)
```
基本的にこちらの方が一般的。値が足りてないとエラーが出てミスに気が付きやすい。<br>
そのため、前者はNULL値を意識的に使う場合に使うと良い。

## データを更新する
```
UPDATE テーブル名 SET カラム名1 = 値, カラム名2 = 値
WHERE 条件式;
```
`=`は、変数の代入みたいな意味。<br>
ちなみに、UPDATEでWHERE句を忘れると、指定したカラムが全部その値になる。

## データを削除する
```
DELETE FROM テーブル名 WHERE 条件式;
```
ちなみに、WHERE句を書かない場合、全部のレコードが削除される。

## テーブルを削除する
```
DROP TABLE テーブル名;
```

## 既存のテーブル名を変更する
```
ALTER TABLE テーブル名 RENAME TO 新しいテーブル名
```

## テーブルを作る
データ型: TEXT(日付もこの型), INTEGER, REAL(浮動小数点数), BLOB(バイナリデータ), NULL<br>
制約: 主キー制約、NOT_NULL制約

```
CREATE TABLE sales (
カラム名1 データ型 制約,
カラム名2 データ型 制約,
...
);
```
### 主キー制約
各レコードを一意に識別するための制約。
```
カラム名 データ型 PRIMARY KEY
```

### NOT_NULL制約
この制約を設定したカラムは、NULL値が禁止される。
```
カラム名 データ型 NOT NULL
```

## テーブルを結合する
```
SELECT カラム名
FROM テーブル名1 INNER JOIN テーブル名2
ON テーブル名1.カラム名 = テーブル名2.カラム名;
```
INNER JOINの後は結合したいテーブル、ONの後は関連付けたいカラム。<br>
SELECTの後のカラム名は、結合する2つテーブルに同じ名前がある場合は、`テーブル名.カラム名`の形で指定する。どちらか片方しかないカラムの場合は、テーブル名を省略できる。

## CSVファイルを書き出す
```
.mode csv /* 表示モードの実行結果をcsvモードに変更数 */
.once ファイル名 /* このコマンド直後のSQL文をテキストデータとして出力する */
SQL文
```

## NULL値を持つデータを探す
```
WHERE カラム名 IS NULL
```
ちなみに、NULL値はCOUNT()でカウントされない。

## コメントアウト
```
/* コメントアウトメッセージ */
```


## TIPS

### 呼び名
列＝属性=カラム<br>
行=レコード=ロウ